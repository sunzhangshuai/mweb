# 索引优化

## 覆盖索引
在命中索引的搜索树上查询得到的值，可以满足查询结果，不需要回表。
- 优点：可以减少树的搜索次数，提升查询性能。
- 缺点：造成索引字段冗余，浪费存储空间，增加维护成本。

## 最左前缀
- 优化原则
    
        联合索引：根据复用性安排索引顺序；若有多个字段需要单独使用，选择空间小的单独建立索引。
- 优点：减少索引的个数。

## 索引下推
可以在索引遍历过程中，先过滤掉一些不满足条件的记录，减少回表次数。        

## 解决mysql用错索引
- 方法一：采用 force index 强行选择一个索引。
- 方法二：可以考虑修改语句，引导 MySQL 使用期望的索引。
- 方法三：可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。
- 方法四：使用analyze table table_name，更正统计信息。

## 不会使用索引的情况
- 使用条件字段函数，不会使用索引的快速搜索功能，进行全索引扫描，eg:
    -  where month(t) = 7; 
    -  where id + 1 = 10000
- 隐式类型转化：字符串转数字，不会使用索引的快速搜索功能，进行全索引扫描，eg: 
    - where user_name = 2; 
- 隐式字符编码转化：如果两个表字符集不同，join时，可能会进行全表扫描
    - 「按数据长度增加的方向」
    - 连接过程中要求在被驱动表的索引字段上加函数操作

## 其他优化

```
1. 设计表结构时，以减少资源消耗为目标。
2. 主键长度越小，普通索引的叶子节点也越小，普通索引占用的空间也约小。
3. 基于非主键索引查询可能会造成回表，因此我们在应用中应该尽量使用主键查询。
4. 在不影响业务时，尽量使用普通索引。
5. 使用哪个索引，是由mysql来决定的。
6. 使用force语句强制使用索引。
7. 对索引字段做函数操作，优化器会放弃走树搜索功能。
8. 当需要使用join时，如果被驱动表可以使用索引，可以使用；当被驱动表不能使用索引，会导致扫描驱动表多次，占用大量的资源，不建议使用。
9. 使用join，需要确认好哪个表作为驱动表，
    1. Index Nested-Loop Join算法，应该选择小表做驱动表。
    2. 如果是 Block Nested-Loop Join 算法：在 join_buffer_size 足够大的时候，是一样的；在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表。
```
