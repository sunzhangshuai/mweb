# 索引优化

## 覆盖索引
在命中索引的搜索树上查询得到的值，可以满足查询结果，不需要回表。
- 优点：可以减少树的搜索次数，提升查询性能。
- 缺点：造成索引字段冗余，浪费存储空间，增加维护成本。

## 最左前缀
- 优化原则
    
        联合索引：根据复用性安排索引顺序；若有多个字段需要单独使用，选择空间小的单独建立索引。
- 优点：减少索引的个数。
- 多索引的排序原则符合基数排序。

## 索引下推
- 在索引遍历中，如果仅能利用前缀索引，可以想办法利用联合索引的其他字段。
- 使用办法：在进行遍历查找时，参数除了能用来遍历索引的字段外，还加入了其他字段，用这个字段进行过滤。
- 索引下推能有效减少回表次数。
- 重点：接口能力，传递时除关键字外，还会传其他字段。

## 解决mysql用错索引
- 方法一：采用 force index 强行选择一个索引。
- 方法二：可以考虑修改语句，引导 MySQL 使用期望的索引。
- 方法三：可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。
- 方法四：使用analyze table table_name，更正统计信息。

## 不会使用索引的情况
- 使用条件字段函数，不会使用索引的快速搜索功能，进行全索引扫描，eg:
    -  where month(t) = 7; 
    -  where id + 1 = 10000
- 隐式类型转化：字符串转数字，不会使用索引的快速搜索功能，进行全索引扫描，eg: 
    - where user_name = 2; 
- 隐式字符编码转化：如果两个表字符集不同，join时，可能会进行全表扫描
    - 「按数据长度增加的方向」
    - 连接过程中要求在被驱动表的索引字段上加函数操作

## 其他优化

```
1. 设计表结构时，以减少资源消耗为目标。
2. 主键长度越小，普通索引的叶子节点也越小，普通索引占用的空间也约小。
3. 基于非主键索引查询可能会造成回表，因此我们在应用中应该尽量使用主键查询。
4. 在不影响业务时，尽量使用普通索引。
5. 使用哪个索引，是由mysql来决定的。
6. 使用force语句强制使用索引。
7. 对索引字段做函数操作，优化器会放弃走树搜索功能。
8. 当需要使用join时，如果被驱动表可以使用索引，可以使用；当被驱动表不能使用索引，会导致扫描驱动表多次，占用大量的资源，不建议使用。
9. 使用join，需要确认好哪个表作为驱动表，
    1. Index Nested-Loop Join算法，应该选择小表做驱动表。
    2. 如果是 Block Nested-Loop Join 算法：在 join_buffer_size 足够大的时候，是一样的；在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表。
```

## 适合不用自增主键的场景
1. 数据库只有1个索引。
2. 索引必须是唯一索引。
    1. 唯一就可以等值查询，查找的过程中不用向后遍历，因为遍历的话，每页存的主键又少了，可能需要查多个页。

## 索引重建
- 普通索引：先删后加，影响不大。
- 主键索引：删除后，mysql会自动生成一个rowid为主键的索引，新增的时候再替换，相当于涉及到两次索引重建，效率不高。
    - 替代方案：alter table T engine=InnoDB。
