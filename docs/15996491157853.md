# 事务

## 事务的实现
1. 事务开始
    1. multi标识事务的开始。
2. 命令入队
    1. 当客户端处于非事务状态时，客户端发送的命令会被立即执行。
    2. 当客户端处于事务状态时。
        1. exec、discard、watch、multi命令会被立即执行。
        2. 其他命令放入事务队列中，向客户端回复queued。
3. 事务执行
    1. 收到exec命令。
    2. 遍历multiState队列，执行所有命令，最后将执行结果返回给客户端。

### 事务队列

```
struct multiState {
    // 事务队列，先入先出
    multiCmd *commands;
    // 已入队命令数
    int count;
}

struct command {
    // 命令参数
    robj *argv;
    // 参数个数
    int argc;
    // 命令指针
    struct redisCommands *cmd;

}
```

## WATCH命令的实现
在执行exec命令前，验证要监视的键是否被修改，如果修改，返回空。
1. 使用watch命令监视数据库键。
    1. redisDb.watched_keys是一个字典，key是数据库键，值是链表，每个节点是一个客户端。
    2. 执行watch命令会在链表中添加客户端节点。
2. 监视机制触发。
    1. 任何对数据库修改的命令，都会遍历watched_keys对应的键值的链表。
    2. touchWatchKey函数会将监视的客户端的REDIS_DITRY_CAS标识打开。表示该客户端的事务安全性已被破坏。
3. 判断事务是否安全
    1. 收到exec命令时，检查redisClient.flags是否打开了REDIS_DITRY_CAS标识。

## 事务的ACID性质

### 原子性
多个操作当成一个整体执行，要么全部操作执行，要么一个操作也不执行。不支持回滚，中间命令出错，事务也会继续执行下去。

### 一致性
如果数据库在执行前是一致的，执行事务之后，数据库也应该是一致的。

#### 保证事务一致性的办法
1. 入队错误：事务入队过程中，发生命令错误，格式不正确等，redis拒绝执行这个事务。
2. 执行错误：
    1. 入队检查没有查出的错误。
    2. 如果发生了错误，也不会听下，会继续往下执行。
3. 服务器停机：
    1. 根据AOF或RDB恢复，恢复到一个一致性的状态。
    
### 隔离性
事务之间是串行的

### 持久性
事务的执行结果被保存至硬盘。redis通过本身的持久化实现 