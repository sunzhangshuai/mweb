# 行级锁
- 同一事务中的锁不会出现锁等待
- 锁是加在索引上的
- 读锁只会给访问到的索引加锁
- 写锁会给访问到的索引和主键索引加锁
- 范围查询的第一次是等值查询

## 行锁

### 作用
为innodb引擎增强并发能力。

### 加锁
- 读锁【共享锁】

        自动加：隔离级别为串行化的时候，查询。
        主动加：lock in share mode

- 写锁【排它锁】

        自动加：数据更新时
        主动加：for update
        
### 解锁
事务提交后释放锁

### 加锁规则
读锁之间不冲突
读写，写锁之间冲突。

### 两阶段锁协议
在需要的时候加锁，在事务提交时释放。

### 死锁
并发的事务都在等待对方释放资源

#### 解决策略
1. 锁等待超时，超时时间由innodb_lock_wait_timeout控制，默认50s
2. 发起死锁检测，发现死锁后，会主动回滚某一个事务，让其他事务继续执行，参数innodb_deadlock_detect设置为on,表示开启死锁检测

## 间隙锁
- 所谓“间隙”，其实根本就是由“这个间隙右边的那个记录”定义的。
- 只在可重复读隔离级别下出现

### 作用
解决可重复读级别下的幻读问题

### 加锁
加在两个记录之间

### 冲突关系
跟间隙锁存在冲突关系的，往往是"往这个间隙中插入一个记录"这个操作，间隙锁之间不存在冲突关系

### 缺点
加锁范围变大，牺牲了一定的并发能力。

## next-key lock
间隙锁+行锁 前开后闭区间
先加间隙锁，再加行锁

### 加锁规则
1. 原则一：加锁的基本单位是next-key lock
2. 原则二：查找过程中访问到的对象才加锁
3. 优化一：索引上的等值查询，给唯一索引加锁的时候，会退化成行锁
4. 优化二：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，退化成间隙锁
5. 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止

