# AOF「append only file」

## 命令追加
服务器执行完一个写命令后，会以请求协议格式追加到服务器状态的aof_buf缓冲区的末尾

## 写入和同步
- 配置：appendonly：no  yes
- 文件的写入和同步
    - 用户调用fwrite函数，操作系统会降写入数据暂时保存在一个内存缓冲区中，等缓冲区空间被填满、或超过指定时限后，才真正将缓冲区的数据写入到磁盘中。
    - fsync和fdatasync：强制将缓冲区数据写入到磁盘中。


### appendfsync
- 每次事件循环执行flushAppendOnlyFile函数。
- flushAppendOnlyFile函数根据服务器配置的appendfsync选项的值来决定写入和同步AOF文件的频率。

值 | flushAppendOnlyFile函数行为
:-: | :--
always | 每次都将缓冲区内容「写入」并「同步」AOF文件。
everysec | 每次都将缓冲区内容「写入」AOF文件，判断上次「同步」AOF文件的时间，和当前时间超过1秒就「同步」。
no | 每次都将缓冲区内容「写入」AOF文件，由操作系统决定何时「同步」

## 文件载入和数据还原
1. 创建一个不带链接的伪客户端。
2. 从AOF文件中分析并读取出一条写指令。
3. 使用伪客户端执行命令。
4. 重复步骤2、3，直到执行完为止。

## AOF重写
- redis将生成新的aof文件替换旧的aof文件的操作定义为aof重写。
- aof重写并不会对旧的aof文件执行任何读取、分析、写入操作。
- 为了避免执行命令造成缓冲区溢出，重写程序在处理列表、哈希、集合、有序集合时，会先检查元素个数。
    - 如果元素超过64个，会解析成多条命令。

### 后台重写
1. 子进程进行重写AOF期间，父进程可以继续处理请求。
2. 子进程带有主进程的数据副本。使用进程而不是线程，可以避免锁的耗时。
3. 使用AOF缓冲区和AOF重写缓冲区处理不一致。
4. 命令：BGREWRITEAOF

#### AOF重写期间，主进程需要做的工作。
1. 执行客户端发来的请求。
2. 将执行后的写命令追加到AOF缓冲区。
3. 将执行后的写命令追加到AOF重写缓冲区。

#### 缓冲区双写的好处
1. 旧的AOF文件处理照常进行。
2. 开启重写子进程后，所有命令都能写入重写缓冲区。

#### 重写过程
1. fork一个子进程，子进程内有主进程的数据副本。
2. 主进程开始缓冲区双写。
3. 子进程重写完成后，向主进程发送信号。
4. 主进程接受到信号，进程阻塞。
5. 主进程将重写缓冲区的数据追加入新的AOF文件。
6. 主进程对新的AOF文件进行改名，覆盖旧的AOF文件。
7. 主进程继续正常工作。


    